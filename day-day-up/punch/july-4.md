# 作用域和闭包

## 词法作用域

函数的词法作用域是由这个函数被声明的位置 **唯一** 定义的。

作用域的查询匹配是从当前作用域开始，逐级向上查找的，**一旦找到第一个匹配，作用域查询就停止了**。

在一个作用域中声明的任何变量都附着在这个作用域上。

## 提升

*引擎* 会在它解释执行你的 JavaScript 代码之前编译它。编译过程的一部分就是找到所有的声明，并将它们关联在合适的作用域上。所以在你的代码的任何部分被执行之前，所有的声明，变量和函数，都会首先被处理。

当你看到 `var a = 2;` 时，你可能认为这是一个语句。但是 JavaScript 实际上认为这是两个语句：`var a;` 和 `a = 2;`。第一个语句，声明，是在编译阶段被处理的。第二个语句，赋值，为了执行阶段而留在 **原处**。

**注意：** 只有声明本身被提升了，而任何赋值或者其他的执行逻辑都被留在 *原处*。

函数声明会被提升，就像我们看到的。但是函数表达式不会。如下所示：

```js
foo(); // 不是 ReferenceError， 而是 TypeError!

var foo = function bar() {
	// ...
};
```

### 函数优先

函数声明和变量声明都会被提升。函数会首先被提升，然后才是变量。

```js
foo(); // 1

var foo;

function foo() {
	console.log( 1 );
}

foo = function() {
	console.log( 2 );
};
```

这个代码段被 *引擎* 解释执行为：

```js
function foo() {
	console.log( 1 );
}

foo(); // 1

foo = function() {
	console.log( 2 );
};
```

> 多个/重复的 `var` 声明实质上是被忽略的，但是后续的函数声明确实会覆盖前一个。

```js
foo(); // 3

function foo() {
	console.log( 1 );
}

var foo = function() {
	console.log( 2 );
};

function foo() {
	console.log( 3 );
}
```

## 闭包

**闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。**

