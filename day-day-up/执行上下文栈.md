## 执行上下文

### 执行上下文类型

执行上下文总共有三种类型

- **全局执行上下文**：只有一个，浏览器中的全局对象就是 window 对象，`this` 指向这个全局对象。
- **函数执行上下文**：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。
- **Eval 函数执行上下文**： 指的是运行在 `eval` 函数中的代码，很少用而且不建议使用。

### 堆栈存储

调用堆栈中函数调用的数量超出了调用堆栈的实际大小，浏览器会抛出一个错误终止运行。

##### 栈

栈的结构就是后进先出**（LIFO）**

##### 堆

堆数据结构是一种树状结构。它的存取数据的方式与书架和书非常相似。我们只需要知道书的名字就可以直接取出书了，并不需要把上面的书取出来。JSON格式的数据中，我们存储的`key-value`可以是无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。

##### 队列

队列是一种先进先出（**FIFO**）的数据结构

##### 变量的存放

JS内存空间分为**栈(stack)**、**堆(heap)**、**池(一般也会归类为栈中)**。 其中**栈**存放变量，**堆**存放复杂对象，**池**存放常量，所以也叫常量池。

- 1、基本类型 --> 保存在**栈**内存中，因为这些类型在内存中分别占有固定大小的空间，通过按值来访问。基本类型一共有6种：Undefined、Null、Boolean、Number 、String和Symbol
- 2、引用类型 --> 保存在**堆**内存中，因为这种值的大小不固定，因此不能把它们保存到栈内存中，但内存地址大小的固定的，因此保存在堆内存中，在栈内存中存放的只是该对象的访问地址。当查询引用类型的变量时， 先从**栈中读取内存地址**， 然后再通过地址**找到堆中的值**。对于这种，我们把它叫做按引用访问。

在计算机的数据结构中，栈比堆的运算速度快，Object是一个复杂的结构且可以扩展：数组可扩充，对象可添加属性，都可以增删改查。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。所以查找引用类型值的时候先去**栈**查找再去**堆**查找。

> 闭包中的变量并不保存在`栈内存中`，而是保存在`堆内存`中，这也就解释了函数之后之后为什么闭包还能引用到函数内的变量。



### 执行栈

执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。

首次运行JS代码时，会创建一个**全局执行上下文**并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个**新的函数执行上下文**并Push到当前执行栈的栈顶。

根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的**函数执行上下文**将会从执行栈中Pop出，上下文控制权将移到当前执行栈的**下一个执行上下文**。



### 执行上下文的创建

当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。

执行上下文分两个阶段创建：

**1）创建阶段；**

 **2）执行阶段**



#### 创建阶段

- 1、确定 **this** 的值，也被称为 **This Binding**。
- 2、**LexicalEnvironment（词法环境）** 组件被创建。
- 3、**VariableEnvironment（变量环境）** 组件被创建。



##### This Binding

- **全局**执行上下文中，`this` 的值指向全局对象，在浏览器中`this` 的值指向 `window `对象，而在`nodejs`中指向这个文件的`module`对象。
- **函数**执行上下文中，`this` 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定（硬绑定）、`new`绑定、箭头函数，具体内容会在【this全面解析】部分详解。



##### 词法环境（Lexical Environment）

词法环境有两个**组成部分**

- 1、**环境记录**：存储变量和函数声明的实际位置
- 2、**对外部环境的引用**：可以访问其外部词法环境

词法环境有两种**类型**

- 1、**全局环境**：是一个没有外部环境的词法环境，其外部环境引用为 **null**。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，`this` 的值指向这个全局对象。
- 2、**函数环境**：用户在函数中定义的变量被存储在**环境记录**中，包含了`arguments` 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。



##### 变量环境

变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。

在 ES6 中，**词法** 环境和 **变量** 环境的区别在于前者用于存储**函数声明和变量（ `let` 和 `const` ）**绑定，而后者仅用于存储**变量（ `var` ）**绑定。



#### 变量提升

在创建阶段，函数声明存储在环境中，而变量会被设置为 `undefined`（在 `var` 的情况下）或保持未初始化（在 `let` 和 `const` 的情况下）。

**变量声明提升**： 通过 `var` 声明的变量在代码执行之前被js引擎提升到了当前作用域的顶部。

**函数声明提升**： 通过函数声明的方式（非函数表达式）声明的函数在代码执行之前被js引擎提升到了当前作用域的顶部，而且函数声明提升优先于变量声明提升。

```js
console.log(s); // undefined
console.log(f()); // This is a function body

var s = 1;
function f(){ console.log('This is a function body')};
```

函数的调用发生在函数声明之前，但是依旧正常执行。其实真正的函数声明只包含如下部分：

```js
function () {
    console.log('This is a function body');
}
```

这部分执行的结果就是创建了一个函数对象，我们假设为 `funcObj`。

`f` 只是指向 `funcObj` 的指针，函数声明提升，提升的应该是创建 `funcObj` 的过程，也就是上述的代码块。

##### 函数声明提升优于变量声明提升

```js
a();

var a;
function a() {
    console.log(1);
}
a = function() {
    console.log(2);
}

a();
```

运行结果：

> 1
>
> 2

上述代码会被js引擎解析为如下：

```js
function a() {
    console.log(1);
}
a();
a = function() {
    console.log(2);
}
a();
```

### 执行阶段

当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。

对于每个执行上下文，都有三个重要属性：

- 变量对象(Variable object，VO)
- 作用域链(Scope chain)
- this


#### 变量对象

变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。

未进入执行阶段之前，变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。


#### 函数上下文

在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。

活动对象AO和变量对象VO其实是一个东西，区别在于

- 1、变量对象（**VO**）是规范上或者是JS引擎上实现的，并不能在JavaScript 环境中直接访问。
- 2、当进入到一个执行上下文后，这个变量对象才会被**激活**，所以叫活动对象activation object（**AO**），这时候活动对象上的各种属性才能被访问。

活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。

#### 执行过程

执行上下文的代码会分成两个阶段进行处理

- 1、**进入**执行上下文
- 2、代码**执行**

#### 进入执行上下文

当进入执行上下文时，这时候还没有执行代码，

变量对象会包括（如下顺序初始化）：

1. 函数的所有形参 (如果是函数上下文)
   - 由名称和对应值组成的一个变量对象的属性被创建
   - 没有实参，属性值设为 undefined
2. 函数声明
   - 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
   - 如果变量对象已经存在相同名称的属性，则完全替换这个属性
3. 变量声明(var)
   - 由名称和对应值（undefined）组成一个变量对象的属性被创建；
   - 如果变量名称跟已经声明的形式参数或函数相同，则**变量声明不会干扰已经存在的这类属性**

上代码就直观了

```js
console.log(foo);

function foo(a, c) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;
}

foo(1, 2);
```

进入执行上下文后，此时的AO是：

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}
```

进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。形参arguments这时候已经有赋值了，但是变量还是undefined，只是初始化的值。

##### 代码执行

进入代码执行阶段，执行第一行`console.log(foo)`的时候AO的值与上面一致，故打印函数而不是`undefined`

这个阶段会顺序执行代码，修改变量对象的值，执行完成后AO如下

```
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}
```

总结如下：

- 1、全局上下文的变量对象初始化是全局对象
- 2、函数上下文的变量对象初始化只包括 Arguments 对象
- 3、在进入执行上下文时会给变量对象**添加形参、函数声明、变量声明**等初始的属性值
- 4、在代码执行阶段，会再次修改变量对象的属性值



有如下两段代码，执行的结果是一样的，但是两段代码究竟有什么不同？

```
// 代码段一：
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();

// 代码段二：
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```

答案是 执行上下文栈的变化不一样。

第一段代码：

```
ECStack.push(<checkscope> functionContext);
ECStack.push(<f> functionContext);
ECStack.pop();
ECStack.pop();
```

第二段代码：

```
ECStack.push(<checkscope> functionContext);
ECStack.pop();
ECStack.push(<f> functionContext);
ECStack.pop();
```



#### 垃圾回收算法

##### 标记清除（常用）

标记清除算法将“不再使用的对象”定义为“**无法到达的对象**”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，**保留**。那些从根部出发无法触及到的对象被标记为**不再使用**，稍后进行回收。

无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。



## 作用域

