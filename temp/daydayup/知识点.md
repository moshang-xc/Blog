# map

第二个参数为this指向，第一个参数fn包含三个参数（当前值，索引，原数组）

# hasOwnProperty

可以用来检测一个对象是否含有特定的自身属性；和 [`in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in) 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。

> 如果数组中的元素为undefined，可以用hasOwnProperty检测出来，为undefined返回值是false

```js
// map实现
function selfMap(fn, thisArg){
    let attr = this.slice(),
        outArr = Array(attr.length);
    for(let i = 0; i < attr.length; i++){
        if(attr.hasOwnProperty(i)){ // 稀疏数组检测，检测key
            outArr[i] = fn.call(thisArg, attr[i], i, this);
        }
    }
    
    return outArr;
}

// some
function some(fn, thisArg){
    let attr = this.slice();
    for(let i = 0; i < attr.length; i++){
        if(attr.hasOwnProperty(i)){ // 稀疏数组检测，检测key
            if(fn.call(thisArg, attr[i], i, this)){
                return true;
            }
        }
    }
    return false;
}
// 执行 some 方法的数组如果是一个空数组，最终始终会返回 false， every 方法会始终返回 true

// reduce
function reduce(fn, initVal){
    let attr = this.slice();
    let startIndex,
        res;
    if(initVal === undefined){
        for(let i = 0; i < attr.length; i++){
            if(attr.hasOwnProperty(i)){
				startIndex = i;
                res = attr[i];
                break;
            }
        }
    }else{
        res = initVal;
        startIndex = -1;
    }
    
    if(res !== undefined){
		for(let i = ++startIndex; i < attr.length; i++){
            if(attr.hasOwnProperty(i)){
				res = fn.call(null, res, attr[i], i, this);
            }
        }
    }
    return res;
}
// 
```

# 菲波那切数列及其优化

```js
function fibonacci(n){
    if(n < 1) return 0;
    if(n === 1 || n === 2){
        return 1;
	}
    return fibonacci(n-1) + fibonacci(n-2);
}

function cached(fn){
    let cache = {};
    return n => cache[n] || (cache[n] = fn(n));
}

fibonacci = cached(fibonacci);
```

# 柯里化Curring

```js
// 直接返回值
function curring(fn, ...args){
    if(fn.length === args.length){
        return fn(...args);
    }
    return function(...args1){
		return curring(fn, ...args, ...args1);
    }
}
// 直接返回fn
function curring(fn){
    if(fn.length <=1){
		return fn;
    }
	function generator(...args){
        if(args.length === fn.length){
            return fn(...args);
        }
        return args1 => {
            return generator(...args, ...args1);
        }
    }
    return generator;
}
```

## 使用场景

### 参数复用

```js
function curring(fn, type){
	return function(){
        return fn(...args, type);
    }
}

function isArray = curring(function(obj, type){
    return Object.prototype.call(obj) === `[object ${type}]`;
}, 'Array')
```

# Object

`Object` 构造函数为给定值创建一个对象包装器。如果给定值是 [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null) 或 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)，将会创建并返回一个空对象，否则，将返回一个与给定值对应类型的对象。

当以非构造函数形式被调用时，`Object` 等同于 `new Object()`。

```js
new Object(null) // {}
new Object(undefined) // {}

let s = {};
new Object(s) === Object(s) // true
Object(s) === s // true

```

### Object.keys()

返回一个包含所有给定对象**自身**可枚举属性名称的数组。

### Object.getOwnPropertyNames()

返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。

```js
var a = {a: 1}
Object.defineProperty(a, 'b', {
	value: 'b',
	enumerable: false
})
var b = Object.create(a)
b.c = 'c'

Object.keys(a) // ['a']
Object.getOwnPropertyNames(a) // ['a', 'b']
Object.keys(b) // ['c']
Object.getOwnPropertyNames(b) // ['c']
```

# BFC

BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。

**具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。**

通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。

### 触发 BFC

只要元素满足下面任一条件即可触发 BFC 特性：

- body 根元素
- 浮动元素：float 除 none 以外的值
- 绝对定位元素：position (absolute、fixed)
- display 为 inline-block、table-cells、flex
- overflow 除了 visible 以外的值 (hidden、auto、scroll)

### BFC 特性及应用

- 同一个 BFC 下元素外边距会发生折叠，分属于不同的BFC时可以阻止margin重叠
- BFC 可以包含浮动的元素（清除浮动）
- BFC 可以阻止元素被浮动元素覆盖
- 计算BFC的高度时，浮动元素也参与计算



# Promise原理

- Promise一旦被解析会永远保持相同的解析结果（完成或拒绝）
- thenable（鸭子类型检查< p !== null && (typeof p === 'function' || typeof p === 'object') && typeof p.then === 'function'>）
- 使用多个参数调用resolve(..)或reject(..)，所有第一个参数之外的后续参数都会被无声地忽略
- Promise被定义为只能被解析一次。如果因为某些原因，Promise的创建代码试着调用resolve(..)或reject(..)许多次，或者试着同时调用它们俩，Promise将仅接受第一次解析，而无声地忽略后续的尝试
- Promise解析或者创建过程中发生语法错误或者手动抛出错误，会强制当前的Promise变为拒绝
- resolve接收基础数据直接返回fullfilled的数据，接收一个Promise或者thenable的值，那么这个值将被递归地展开，而且无论它最终解析结果/状态是什么，都将被promise采用。
- reject(..) 不会 像resolve(..)那样进行展开。如果你向reject(..)传递一个Promise/thenable值，这个没有被碰过的值将作为拒绝的理由。
- Promise.all([ .. ])、Promise.race([ .. ])将会在任意一个Promise解析为拒绝时拒绝。
- Promise.resolve(),传入一个纯粹的Promise，Promise.resolve(..)不会做任何事情,它仅仅会直接返回这个值





# 移动端开发问题

## position: fixed

1. 随着页面抖动
2. 有输入框时，弹出软键盘会有各种问题
3. 偶尔无法滚动

> 移动端尽量不要使用fixed布局

## -webkit-overflow-scrolling:touch

1. `scrollTop`无法变化
2. 滚动时暂停其他 transition
3. 页面偶尔会卡住不动
4. 在safari上，点击其他区域，再在滚动区域滑动，滚动条无法滚动的bug。
5. 通过动态添加内容撑开容器，结果根本不能滑动的bug。

### 解决方案

1. 如果出现偶尔卡住不动的情况，那么在使用该属性的元素上不设置定位或者手动设置定位为`static`

   ```
   position: static
   ```

2. 如果在-webkit-overflow-scrolling:touch属性的元素上，想通过动态添加内容来撑开容器，触发滚动，是有bug 的，页面是会卡住不动的。

   方法就是在webkit-overflow-scrolling:touch属性的下一层子元素上，将height加1%或1px。从而主动触发scrollbar。

   ```
   <div class="main">
   	<div class="main-inner"></div>
   </div>
   
   .main .main-inner{
   	min-height: 101%;
   }
   // 或
   .main:after {
       min-height: calc(100% + 1px)
   }
   ```

   

## 软键盘弹起

### `IOS` 软键盘弹起表现

在 `IOS` 上，输入框（`input`、`textarea` 或 富文本）获取焦点，键盘弹起，页面（`webview`）并没有被压缩，或者说高度（`height`）没有改变，只是页面（`webview`）整体往上滚了，且最大滚动高度（`scrollTop`）为软键盘高度。

### `Android` 软键盘弹起表现

同样，在 `Android` 上，输入框获取焦点，键盘弹起，但是页面（`webview`）高度会发生改变，一般来说，高度为可视区高度（原高度减去软键盘高度），除了因为页面内容被撑开可以产生滚动，`webview` 本身不能滚动。

### `IOS` 软键盘收起表现

触发软键盘上的“收起”按钮键盘或者输入框以外的页面区域时，输入框失去焦点，软键盘收起。

### `Android` 软键盘收起表现

触发输入框以外的区域时，输入框失去焦点，软键盘收起。但是，触发键盘上的收起按钮键盘时，输入框并不会失去焦点，同样软键盘收起。

### 监听软键盘弹起和收起

```js
// 判断设备类型
var judgeDeviceType = function () {
  var ua = window.navigator.userAgent.toLocaleLowerCase();
  var isIOS = /iphone|ipad|ipod/.test(ua);
  var isAndroid = /android/.test(ua);

  return {
    isIOS: isIOS,
    isAndroid: isAndroid
  }
}()

// 监听输入框的软键盘弹起和收起事件
function listenKeybord($input) {
  if (judgeDeviceType.isIOS) {
    // IOS 键盘弹起：IOS 和 Android 输入框获取焦点键盘弹起
    $input.addEventListener('focus', function () {
      console.log('IOS 键盘弹起啦！');
      // IOS 键盘弹起后操作
    }, false)

    // IOS 键盘收起：IOS 点击输入框以外区域或点击收起按钮，输入框都会失去焦点，键盘会收起，
    $input.addEventListener('blur', () => {
      console.log('IOS 键盘收起啦！');
      // IOS 键盘收起后操作
    })
  }

  // Andriod 键盘收起：Andriod 键盘弹起或收起页面高度会发生变化，以此为依据获知键盘收起
  if (judgeDeviceType.isAndroid) {
    var originHeight = document.documentElement.clientHeight || document.body.clientHeight;

    window.addEventListener('resize', function () {
      var resizeHeight = document.documentElement.clientHeight || document.body.clientHeight;
      if (originHeight < resizeHeight) {
        console.log('Android 键盘收起啦！');
        // Android 键盘收起后操作
      } else {
        console.log('Android 键盘弹起啦！');
        // Android 键盘弹起后操作
      }

      originHeight = resizeHeight;
    }, false)
  }
}

var $inputs = document.querySelectorAll('.input');

for (var i = 0; i < $inputs.length; i++) {
  listenKeybord($inputs[i]);
}
```

### 让输入框滚动到可视区域

```js
activeElement.scrollIntoView();
```

> 参考文档： https://segmentfault.com/a/1190000018959389

# 懒加载

当对 `<img>` 元素进行懒加载时，我们会通过 JavaScript 来判断 `<img>` 元素是否在视口内，如果元素在视口内，则它的 `src` 属性(有时也用 `srcset`)会用 data-src填充来加载所需的图像内容，初始状态img加载的是一个占位符图片，出现在视口中再进行替换。

```html
<img class="lazy" src="placeholder-image.jpg" data-src="image-to-lazy-load-1x.jpg" data-srcset="image-to-lazy-load-2x.jpg 2x, image-to-lazy-load-1x.jpg 1x" alt="I'm an image!">
```

## 使用`IntersectionObserver`API实现

```js
document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll("img.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target;
          lazyImage.src = lazyImage.dataset.src;
          lazyImage.srcset = lazyImage.dataset.srcset;
          lazyImage.classList.remove("lazy");
          lazyImageObserver.unobserve(lazyImage);
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage);
    });
  } else {
    // Possibly fall back to a more compatible method here
  }
});
```

## 使用事件监听实现

下面介绍使用事件监听，兼容性较好。

**getBoundingClientRect()**：

`getBoundingClientRect`用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置。`getBoundingClientRect`是`DOM`元素到浏览器可视范围的距离（不包含文档卷起的部分）。

判断元素是否在视区

```js
function checkDom(dom){
    let rect = dom.getBoundingClientRect();
    return rect.top <= (window.innerHeight || document.documentElement.clientHeight) && rect.bottom >=0 && getComputedStyle(dom).display !== "none";
}

// 或
function checkDom(dom){
    let rect = dom.getBoundingClientRect();
     return (
        rect.top >= 0 &&
        rect.left >= 0 &&
        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && 
        rect.right <= (window.innerWidth || document.documentElement.clientWidth) && 
        getComputedStyle(dom).display !== "none";
    );
}
```

https://github.com/dwqs/blog/issues/74

# viewport

## 视觉视口



## 布局视口



## 理想视口

- 通过 viewport 的 `meta` 标签，布局视口可被设置成理想视口的值：

```
<meta name="viewport" content="width=device-width,initial-scale=1">
```



# performance

## Performance.timing属性详解

- PerformanceTiming.navigationStart 

  表示从同一个浏览器上下文的上一个文档卸载(unload)结束时的UNIX时间戳。如果没有上一个文档，这个值会和`PerformanceTiming.fetchStart`相同。

- PerformanceTiming.unloadEventStart

  表示`unload`事件抛出时的UNIX时间戳。如果没有上一个文档，or if the previous document, or one of the needed redirects, is not of the same origin, 这个值会返回0.

- PerformanceTiming.unloadEventEnd

  表示`unload`事件处理完成时的UNIX时间戳。如果没有上一个文档，or if the previous document, or one of the needed redirects, is not of the same origin, 这个值会返回0.

- PerformanceTiming.redirectStart

  表示第一个HTTP重定向开始时的UNIX时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0.

- PerformanceTiming.redirectEnd

  表示最后一个HTTP重定向完成时（也就是说是HTTP响应的最后一个比特直接被收到的时间）的UNIX时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0.

- **PerformanceTiming.fetchStart**

  表示浏览器准备好使用HTTP请求来获取(fetch)文档的UNIX时间戳。这个时间点会在检查任何应用缓存之前。

- PerformanceTiming.domainLookupStart

  表示域名查询(DNS查询)开始的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 `PerformanceTiming.fetchStart一致。`

- PerformanceTiming.domainLookupEnd

  表示域名查询结束的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 `PerformanceTiming.fetchStart一致。`

- PerformanceTiming.connectStart

  返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值。（TCP连接时间）

- PerformanceTiming.connectEnd

  返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。

- PerformanceTiming.secureConnectionStart（https）

  返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0。

- PerformanceTiming.requestStart

  返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳。

- **PerformanceTiming.responseStart**

  返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳。如果传输层在开始请求之后失败并且连接被重开，该属性将会被数制成新的请求的相对应的发起时间。

- **PerformanceTiming.responseEnd**

  返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳。

- **PerformanceTiming.domLoading**

  返回当前网页DOM结构开始解析时（即[`Document.readyState`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState)属性变为“loading”、相应的 `readystatechange`事件触发时）的Unix毫秒时间戳。

- **PerformanceTiming.domInteractive**

  返回当前网页DOM结构结束解析、开始加载内嵌资源时（即[`Document.readyState`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState)属性变为“interactive”、相应的`readystatechange`事件触发时）的Unix毫秒时间戳。

- PerformanceTiming.domContentLoadedEventStart

  返回当解析器发送`DOMContentLoaded` 事件，即所有需要被执行的脚本已经被解析时的Unix毫秒时间戳。

- PerformanceTiming.domContentLoadedEventEnd

  返回当所有需要立即执行的脚本已经被执行（不论执行顺序）时的Unix毫秒时间戳。

- **PerformanceTiming.domComplete**

  返回当前文档解析完成，即[`Document.readyState`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState) 变为 `'complete'且相对应的``readystatechange` 被触发时的Unix毫秒时间戳。

- PerformanceTiming.loadEventStart

  返回该文档下，`load`事件被发送时的Unix毫秒时间戳。如果这个事件还未被发送，它的值将会是0。

- PerformanceTiming.loadEventEnd

  返回当`load`事件结束，即加载事件完成时的Unix毫秒时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是0.

## 计算性能指标

  - DNS查询： domainLookupEnd - domainLookupStart
  - TCP连接耗时：connectEnd - connectStart
  - request请求耗时：responseEnd - requestStart
  - 解析DOM：domInteractive - domLoading
  - 白屏时间：domLoading - fetchStart
  - domready：domContentLoadedEventEnd - fetchStart
  - onload：loadEventEnd - fetchStart