# map

第二个参数为this指向，第一个参数fn包含三个参数（当前值，索引，原数组）

# hasOwnProperty

可以用来检测一个对象是否含有特定的自身属性；和 [`in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in) 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。

> 如果数组中的元素为undefined，可以用hasOwnProperty检测出来，为undefined返回值是false

```js
// map实现
function selfMap(fn, thisArg){
    let attr = this.slice(),
        outArr = Array(attr.length);
    for(let i = 0; i < attr.length; i++){
        if(attr.hasOwnProperty(i)){ // 稀疏数组检测，检测key
            outArr[i] = fn.call(thisArg, attr[i], i, this);
        }
    }
    
    return outArr;
}

// some
function some(fn, thisArg){
    let attr = this.slice();
    for(let i = 0; i < attr.length; i++){
        if(attr.hasOwnProperty(i)){ // 稀疏数组检测，检测key
            if(fn.call(thisArg, attr[i], i, this)){
                return true;
            }
        }
    }
    return false;
}
// 执行 some 方法的数组如果是一个空数组，最终始终会返回 false， every 方法会始终返回 true

// reduce
function reduce(fn, initVal){
    let attr = this.slice();
    let startIndex,
        res;
    if(initVal === undefined){
        for(let i = 0; i < attr.length; i++){
            if(attr.hasOwnProperty(i)){
				startIndex = i;
                res = attr[i];
                break;
            }
        }
    }else{
        res = initVal;
        startIndex = -1;
    }
    
    if(res !== undefined){
		for(let i = ++startIndex; i < attr.length; i++){
            if(attr.hasOwnProperty(i)){
				res = fn.call(null, res, attr[i], i, this);
            }
        }
    }
    return res;
}
// 
```

# 菲波那切数列及其优化

```js
function fibonacci(n){
    if(n < 1) return 0;
    if(n === 1 || n === 2){
        return 1;
	}
    return fibonacci(n-1) + fibonacci(n-2);
}

function cached(fn){
    let cache = {};
    return n => cache[n] || (cache[n] = fn(n));
}

fibonacci = cached(fibonacci);
```

# 柯里化Curring

```js
// 直接返回值
function curring(fn, ...args){
    if(fn.length === args.length){
        return fn(...args);
    }
    return function(...args1){
		return curring(fn, ...args, ...args1);
    }
}
// 直接返回fn
function curring(fn){
    if(fn.length <=1){
		return fn;
    }
	function generator(...args){
        if(args.length === fn.length){
            return fn(...args);
        }
        return args1 => {
            return generator(...args, ...args1);
        }
    }
    return generator;
}
```

## 使用场景

### 参数复用

```js
function curring(fn, type){
	return function(){
        return fn(...args, type);
    }
}

function isArray = curring(function(obj, type){
    return Object.prototype.call(obj) === `[object ${type}]`;
}, 'Array')
```

# Object

`Object` 构造函数为给定值创建一个对象包装器。如果给定值是 [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null) 或 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)，将会创建并返回一个空对象，否则，将返回一个与给定值对应类型的对象。

当以非构造函数形式被调用时，`Object` 等同于 `new Object()`。

```js
new Object(null) // {}
new Object(undefined) // {}

let s = {};
new Object(s) === Object(s) // true
Object(s) === s // true

```

### Object.keys()

返回一个包含所有给定对象**自身**可枚举属性名称的数组。

### Object.getOwnPropertyNames()

返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。

```js
var a = {a: 1}
Object.defineProperty(a, 'b', {
	value: 'b',
	enumerable: false
})
var b = Object.create(a)
b.c = 'c'

Object.keys(a) // ['a']
Object.getOwnPropertyNames(a) // ['a', 'b']
Object.keys(b) // ['c']
Object.getOwnPropertyNames(b) // ['c']
```

# BFC

BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。

**具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。**

通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。

### 触发 BFC

只要元素满足下面任一条件即可触发 BFC 特性：

- body 根元素
- 浮动元素：float 除 none 以外的值
- 绝对定位元素：position (absolute、fixed)
- display 为 inline-block、table-cells、flex
- overflow 除了 visible 以外的值 (hidden、auto、scroll)

### BFC 特性及应用

- 同一个 BFC 下元素外边距会发生折叠，分属于不同的BFC时可以阻止margin重叠
- BFC 可以包含浮动的元素（清除浮动）
- BFC 可以阻止元素被浮动元素覆盖
- 计算BFC的高度时，浮动元素也参与计算



# Promise原理

- Promise一旦被解析会永远保持相同的解析结果（完成或拒绝）
- thenable（鸭子类型检查< p !== null && (typeof p === 'function' || typeof p === 'object') && typeof p.then === 'function'>）
- 使用多个参数调用resolve(..)或reject(..)，所有第一个参数之外的后续参数都会被无声地忽略
- Promise被定义为只能被解析一次。如果因为某些原因，Promise的创建代码试着调用resolve(..)或reject(..)许多次，或者试着同时调用它们俩，Promise将仅接受第一次解析，而无声地忽略后续的尝试
- Promise解析或者创建过程中发生语法错误或者手动抛出错误，会强制当前的Promise变为拒绝
- resolve接收基础数据直接返回fullfilled的数据，接收一个Promise或者thenable的值，那么这个值将被递归地展开，而且无论它最终解析结果/状态是什么，都将被promise采用，保留结果的状态。
- reject(..) 不会 像resolve(..)那样进行展开。如果你向reject(..)传递一个Promise/thenable值，这个没有被碰过的值将作为拒绝的理由。
- Promise.all([ .. ])、Promise.race([ .. ])将会在任意一个Promise解析为拒绝时拒绝。
- Promise.resolve(),传入一个纯粹的Promise，Promise.resolve(..)不会做任何事情,它仅仅会直接返回这个值

```js
Promise.all([new Promise((resolve)=>{
  setTimeout(()=>{
    resolve(1);
  }, 100);
}), new Promise((resolve, reject)=>{
  setTimeout(()=>{
    reject(2)
  }, 1000)
})
]).then(console.log, console.log) // reject：2

Promise.race([new Promise((resolve)=>{
  setTimeout(()=>{
    resolve(1);
  }, 100);
}), new Promise((resolve, reject)=>{
  setTimeout(()=>{
    reject(2)
  }, 100)
})
]).then(console.log, console.log) // resolve：1

Promise.race([new Promise((resolve)=>{
  setTimeout(()=>{
    resolve(1);
  }, 1000);
}), new Promise((resolve, reject)=>{
  setTimeout(()=>{
    reject(2)
  }, 100)
})
]).then(console.log, console.log) // reject：2
```



# 移动端开发问题

## position: fixed

1. 随着页面抖动
2. 有输入框时，弹出软键盘会有各种问题
3. 偶尔无法滚动

> 移动端尽量不要使用fixed布局

## -webkit-overflow-scrolling:touch

1. `scrollTop`无法变化
2. 滚动时暂停其他 transition
3. 页面偶尔会卡住不动
4. 在safari上，点击其他区域，再在滚动区域滑动，滚动条无法滚动的bug。
5. 通过动态添加内容撑开容器，结果根本不能滑动的bug。

### 解决方案

1. 如果出现偶尔卡住不动的情况，那么在使用该属性的元素上不设置定位或者手动设置定位为`static`

   ```
   position: static
   ```

2. 如果在-webkit-overflow-scrolling:touch属性的元素上，想通过动态添加内容来撑开容器，触发滚动，是有bug 的，页面是会卡住不动的。

   方法就是在webkit-overflow-scrolling:touch属性的下一层子元素上，将height加1%或1px。从而主动触发scrollbar。

   ```
   <div class="main">
   	<div class="main-inner"></div>
   </div>
   
   .main .main-inner{
   	min-height: 101%;
   }
   // 或
   .main:after {
       min-height: calc(100% + 1px)
   }
   ```

   

## 软键盘弹起

### `IOS` 软键盘弹起表现

在 `IOS` 上，输入框（`input`、`textarea` 或 富文本）获取焦点，键盘弹起，页面（`webview`）并没有被压缩，或者说高度（`height`）没有改变，只是页面（`webview`）整体往上滚了，且最大滚动高度（`scrollTop`）为软键盘高度。

### `Android` 软键盘弹起表现

同样，在 `Android` 上，输入框获取焦点，键盘弹起，但是页面（`webview`）高度会发生改变，一般来说，高度为可视区高度（原高度减去软键盘高度），除了因为页面内容被撑开可以产生滚动，`webview` 本身不能滚动。

### `IOS` 软键盘收起表现

触发软键盘上的“收起”按钮键盘或者输入框以外的页面区域时，输入框失去焦点，软键盘收起。

### `Android` 软键盘收起表现

触发输入框以外的区域时，输入框失去焦点，软键盘收起。但是，触发键盘上的收起按钮键盘时，输入框并不会失去焦点，同样软键盘收起。

### 监听软键盘弹起和收起

```js
// 判断设备类型
var judgeDeviceType = function () {
  var ua = window.navigator.userAgent.toLocaleLowerCase();
  var isIOS = /iphone|ipad|ipod/.test(ua);
  var isAndroid = /android/.test(ua);

  return {
    isIOS: isIOS,
    isAndroid: isAndroid
  }
}()

// 监听输入框的软键盘弹起和收起事件
function listenKeybord($input) {
  if (judgeDeviceType.isIOS) {
    // IOS 键盘弹起：IOS 和 Android 输入框获取焦点键盘弹起
    $input.addEventListener('focus', function () {
      console.log('IOS 键盘弹起啦！');
      // IOS 键盘弹起后操作
    }, false)

    // IOS 键盘收起：IOS 点击输入框以外区域或点击收起按钮，输入框都会失去焦点，键盘会收起，
    $input.addEventListener('blur', () => {
      console.log('IOS 键盘收起啦！');
      // IOS 键盘收起后操作
    })
  }

  // Andriod 键盘收起：Andriod 键盘弹起或收起页面高度会发生变化，以此为依据获知键盘收起
  if (judgeDeviceType.isAndroid) {
    var originHeight = document.documentElement.clientHeight || document.body.clientHeight;

    window.addEventListener('resize', function () {
      var resizeHeight = document.documentElement.clientHeight || document.body.clientHeight;
      if (originHeight < resizeHeight) {
        console.log('Android 键盘收起啦！');
        // Android 键盘收起后操作
      } else {
        console.log('Android 键盘弹起啦！');
        // Android 键盘弹起后操作
      }

      originHeight = resizeHeight;
    }, false)
  }
}

var $inputs = document.querySelectorAll('.input');

for (var i = 0; i < $inputs.length; i++) {
  listenKeybord($inputs[i]);
}
```

### 让输入框滚动到可视区域

```js
activeElement.scrollIntoView();
```

> 参考文档： https://segmentfault.com/a/1190000018959389

# 懒加载

当对 `<img>` 元素进行懒加载时，我们会通过 JavaScript 来判断 `<img>` 元素是否在视口内，如果元素在视口内，则它的 `src` 属性(有时也用 `srcset`)会用 data-src填充来加载所需的图像内容，初始状态img加载的是一个占位符图片，出现在视口中再进行替换。

```html
<img class="lazy" src="placeholder-image.jpg" data-src="image-to-lazy-load-1x.jpg" data-srcset="image-to-lazy-load-2x.jpg 2x, image-to-lazy-load-1x.jpg 1x" alt="I'm an image!">
```

## 使用`IntersectionObserver`API实现

```js
document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll("img.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target;
          lazyImage.src = lazyImage.dataset.src;
          lazyImage.srcset = lazyImage.dataset.srcset;
          lazyImage.classList.remove("lazy");
          lazyImageObserver.unobserve(lazyImage);
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage);
    });
  } else {
    // Possibly fall back to a more compatible method here
  }
});
```

## 使用事件监听实现

下面介绍使用事件监听，兼容性较好。

**getBoundingClientRect()**：

`getBoundingClientRect`用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置。`getBoundingClientRect`是`DOM`元素到浏览器可视范围的距离（不包含文档卷起的部分）。

判断元素是否在视区

```js
function checkDom(dom){
    let rect = dom.getBoundingClientRect();
    return rect.top <= (window.innerHeight || document.documentElement.clientHeight) && rect.bottom >=0 && getComputedStyle(dom).display !== "none";
}

// 或
function checkDom(dom){
    let rect = dom.getBoundingClientRect();
     return (
        rect.top >= 0 &&
        rect.left >= 0 &&
        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && 
        rect.right <= (window.innerWidth || document.documentElement.clientWidth) && 
        getComputedStyle(dom).display !== "none";
    );
}
```

https://github.com/dwqs/blog/issues/74



# performance

## Performance.timing属性详解

- PerformanceTiming.navigationStart 

  表示从同一个浏览器上下文的上一个文档卸载(unload)结束时的UNIX时间戳。如果没有上一个文档，这个值会和`PerformanceTiming.fetchStart`相同。

- PerformanceTiming.unloadEventStart

  表示`unload`事件抛出时的UNIX时间戳。如果没有上一个文档，or if the previous document, or one of the needed redirects, is not of the same origin, 这个值会返回0.

- PerformanceTiming.unloadEventEnd

  表示`unload`事件处理完成时的UNIX时间戳。如果没有上一个文档，or if the previous document, or one of the needed redirects, is not of the same origin, 这个值会返回0.

- PerformanceTiming.redirectStart

  表示第一个HTTP重定向开始时的UNIX时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0.

- PerformanceTiming.redirectEnd

  表示最后一个HTTP重定向完成时（也就是说是HTTP响应的最后一个比特直接被收到的时间）的UNIX时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0.

- **PerformanceTiming.fetchStart**

  表示浏览器准备好使用HTTP请求来获取(fetch)文档的UNIX时间戳。这个时间点会在检查任何应用缓存之前。

- PerformanceTiming.domainLookupStart

  表示域名查询(DNS查询)开始的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 `PerformanceTiming.fetchStart一致。`

- PerformanceTiming.domainLookupEnd

  表示域名查询结束的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 `PerformanceTiming.fetchStart一致。`

- PerformanceTiming.connectStart

  返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值。（TCP连接时间）

- PerformanceTiming.connectEnd

  返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。

- PerformanceTiming.secureConnectionStart（https）

  返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0。

- PerformanceTiming.requestStart

  返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳。

- **PerformanceTiming.responseStart**

  返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳。如果传输层在开始请求之后失败并且连接被重开，该属性将会被数制成新的请求的相对应的发起时间。

- **PerformanceTiming.responseEnd**

  返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳。

- **PerformanceTiming.domLoading**

  返回当前网页DOM结构开始解析时（即[`Document.readyState`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState)属性变为“loading”、相应的 `readystatechange`事件触发时）的Unix毫秒时间戳。

- **PerformanceTiming.domInteractive**

  返回当前网页DOM结构结束解析、开始加载内嵌资源时（即[`Document.readyState`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState)属性变为“interactive”、相应的`readystatechange`事件触发时）的Unix毫秒时间戳。

- PerformanceTiming.domContentLoadedEventStart

  返回当解析器发送`DOMContentLoaded` 事件，即所有需要被执行的脚本已经被解析时的Unix毫秒时间戳。

- PerformanceTiming.domContentLoadedEventEnd

  返回当所有需要立即执行的脚本已经被执行（不论执行顺序）时的Unix毫秒时间戳。

- **PerformanceTiming.domComplete**

  返回当前文档解析完成，即[`Document.readyState`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState) 变为 `'complete'且相对应的``readystatechange` 被触发时的Unix毫秒时间戳。

- PerformanceTiming.loadEventStart

  返回该文档下，`load`事件被发送时的Unix毫秒时间戳。如果这个事件还未被发送，它的值将会是0。

- PerformanceTiming.loadEventEnd

  返回当`load`事件结束，即加载事件完成时的Unix毫秒时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是0.

## 计算性能指标

  - DNS查询： domainLookupEnd - domainLookupStart
  - TCP连接耗时：connectEnd - connectStart
  - request请求耗时：responseEnd - requestStart
  - 解析DOM：domInteractive - domLoading
  - 白屏时间：domLoading - fetchStart
  - domready：domContentLoadedEventEnd - fetchStart
  - onload：loadEventEnd - fetchStart

## 对象字面量{}， new Object()和Object.create()有什么区别？

```js
var s = {},
    k = new Object(),
    k1 = new Object(1), // 等价于 new Number(1);
    h = Object.create({});// 传入的参数即为创建对象的`__proto__`

s.__proto__ === Object.prototype // true
k.__proto__ === Object.prototype // true
k1.__proto__ === Object.prototype // false
k1.__proto__ === Number.prototype // true
h.__proto__ === Object.prototype // false
```

**解释**:

**Object()**

`Object` 构造函数为给定值创建一个对象包装器。如果给定值是 [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null) 或 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)，将会创建并返回一个空对象，否则，将返回一个与给定值对应类型的对象。当以非构造函数形式被调用时，`Object` 等同于 `new Object()`。

**Object.create()**

`Object.create()`方法接受两个参数:`Object.create(obj,propertiesObject)`
`obj`:一个对象，应该是新创建的对象的原型。
`propertiesObject`：可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符（这些属性描述符的结构与Object.defineProperties()的第二个参数一样）。注意：该参数对象不能是 undefined，另外只有该对象中自身拥有的可枚举的属性才有效，也就是说该对象的原型链上属性是无效的。

Object.create(null) 创建的对象是一个空对象，在该对象上没有继承 Object.prototype 原型链上的属性或者方法,例如：toString(), hasOwnProperty()等方法

Vue源码中的extend就是通过`Object.create`来实现的。

#### new 运算符的执行过程？

1. 一个全新的对象会凭空创建（就是被构建）
2. *这个新构建的对象会被接入原形链（[[Prototype]]-linked）*
3. 这个新构建的对象被设置为函数调用的 `this` 绑定
4. 除非函数返回一个它自己的其他 **对象**，否则这个被 `new` 调用的函数将 *自动* 返回这个新构建的对象。

```js
function new(func){
    let target = {};
    let Constructor = [].shift.call(arguments);
    target.__proto__ = Constructor.prototype;
    var res = Constructor.apply(target, arguments);
    
    return typeof res === 'object' ? res : target;
}
```

## null和undefined

JavaScript的最初版本是这样区分的：**null是一个表示"无"的对象，转为数值时为0；undefined是一个表示"无"的原始值，转为数值时为NaN。**

```js
Number(null)
// 0

5 + null
// 5

Number(undefined)
// NaN

5 + undefined
// NaN
```

按存储来分析给一个全局变量赋值为null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性 赋值为null，或者局部变量赋值为null，相当于给这个属性分配了一块空的内存，然后值为null， JS会回收全局变量为null的对象。

给一个全局变量赋值为undefined，相当于将这个对象的值清空，但是这个对象依旧存在，如果是给对象的属性赋值 为undefined，说明这个值为空值

声明了一个变量，但未对其初始化时，这个变量的值就是undefined，它是 JavaScript 基本类型 之一。

```
var data;
console.log(data === undefined); //true
```

**对于尚未声明过的变量，只能执行一项操作，即使用typeof操作符检测其数据类型**，使用其他的操作都会报错。

```
//data变量未定义
console.log(typeof data); // "undefined"
console.log(data === undefined); //报错
```

值 `null` 特指对象的值未设置，它是 JavaScript 基本类型 之一。

值 `null` 是一个字面量，它不像[`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined) 是全局对象的一个属性。`null` 是表示缺少的标识，指示变量未指向任何对象。

```
// foo不存在，它从来没有被定义过或者是初始化过：
foo;
"ReferenceError: foo is not defined"

// foo现在已经是知存在的，但是它没有类型或者是值：
var foo = null; 
console.log(foo);	// null
```

## 数组去重

```js
// 排序去重
function unique(array) {
    var res = [];
    var sortedArray = array.concat().sort();
    var seen;
    for (var i = 0, len = sortedArray.length; i < len; i++) {
        // 如果是第一个元素或者相邻的元素不相同
        if (!i || seen !== sortedArray[i]) {
            res.push(sortedArray[i])
        }
        seen = sortedArray[i];
    }
    return res;
}

// Object去重  有问题无法区分1和'1'等
function unique(array) {
    var obj = {};
    return array.filter(function(item, index, array){
        return obj.hasOwnProperty(item) ? false : (obj[item] = true)
    })
}

// Es6
function unique(array) {
   return Array.from(new Set(array));
}

var unique = (a) => [...new Set(a)]

// map
function unique (arr) {
    const seen = new Map()
    return arr.filter((a) => !seen.has(a) && seen.set(a, 1))
}
```

## 类型判断

### typeof

typeof 是一元操作符，放在其单个操作数的前面，操作数可以是任意类型。返回值为表示操作数类型的一个字符串。

```js
typeof 'moshang' // string
```

typeof操作对应的值

| typeof | Undefined | Null   | Boolean | Number | String | Object | Function |
| ------ | --------- | ------ | ------- | ------ | ------ | ------ | -------- |
| 值     | undefined | object | boolean | number | string | object | function |

### instanceof

`instanceof `运算符用来检测 `constructor.prototype `是否存在于参数 `object` 的原型链上。

instanceof 是通过原型链判断的，A instanceof B, 在A的原型链中层层查找，是否有原型等于B.prototype，如果一直找到A的原型链的顶端(null;即Object.prototype.__proto__),仍然不等于B.prototype，那么返回false，否则返回true.

> 对于内置的基础数据类型，`instanceof`的返回值永远都是`false`

```js
'a' instanceof String // false
true instanceof Boolean // false
new Boolean(true) instanceof Boolean // true

```

**insranceof实现**

```js
function instanceof(sub, sup){
    let subPro = sub.__proto__,
        supPro = sup.prototype;

    while(true){
        if(subPro === null){
            return false;
        }else if(subPro === supPro){
            return true;
        }
        subPro = subPro.__proto__;
    }
}
```

### Object.prototype.toString

```js
// 以下是11种：
var number = 1;          // [object Number]
var string = '123';      // [object String]
var boolean = true;      // [object Boolean]
var und = undefined;     // [object Undefined]
var nul = null;          // [object Null]
var obj = {a: 1}         // [object Object]
var array = [1, 2, 3];   // [object Array]
var date = new Date();   // [object Date]
var error = new Error(); // [object Error]
var reg = /a/g;          // [object RegExp]
var func = function a(){}; // [object Function]

console.log(Object.prototype.toString.call(Math)); // [object Math]
console.log(Object.prototype.toString.call(JSON)); // [object JSON]

function a() {
    console.log(Object.prototype.toString.call(arguments)); // [object Arguments]
}
a();
```

### type API

```js
var class2type = {};

// 生成class2type映射
"Boolean Number String Function Array Date RegExp Object Error".split(" ").map(function(item, index) {
    class2type["[object " + item + "]"] = item.toLowerCase();
})

function type(obj) {
    // 一箭双雕
    if (obj == null) {
        return obj + "";
    }
    return typeof obj === "object" || typeof obj === "function" ?
        class2type[Object.prototype.toString.call(obj)] || "object" :
        typeof obj;
}
```

### plainObject

除了 {} 和 new Object 创建的之外，jQuery 认为一个没有原型的对象也是一个纯粹的对象。

```js
// 相当于 Object.prototype.toString
var toString = ({}).toString;
// 相当于 Object.prototype.hasOwnProperty
var hasOwn = ({}).hasOwnProperty;

function isPlainObject(obj) {
    var proto, Ctor;

    // 排除掉明显不是obj的以及一些宿主对象如Window
    if (!obj || toString.call(obj) !== "[object Object]") {
        return false;
    }

    /**
     * getPrototypeOf es5 方法，获取 obj 的原型
     * 以 new Object 创建的对象为例的话
     * obj.__proto__ === Object.prototype
     */
    proto = Object.getPrototypeOf(obj);

    // 没有原型的对象是纯粹的，Object.create(null) 就在这里返回 true
    if (!proto) {
        return true;
    }

    /**
     * 以下判断通过 new Object 方式创建的对象
     * 判断 proto 是否有 constructor 属性，如果有就让 Ctor 的值为 proto.constructor
     * 如果是 Object 函数创建的对象，Ctor 在这里就等于 Object 构造函数
     */
    Ctor = hasOwn.call(proto, "constructor") && proto.constructor;

    // 在这里判断 Ctor 构造函数是不是 Object 构造函数，用于区分自定义构造函数和 Object 构造函数
    // hasOwn.toString返回当前函数源代码的字符串，参考Function.prototype.toString
    return typeof Ctor === "function" && hasOwn.toString.call(Ctor) === hasOwn.toString.call(Object); 
}
```



### EmptyObject

jQuery提供了 `isEmptyObject` 方法来判断是否是空对象，代码简单，我们直接看源码：

```js
function isEmptyObject( obj ) {

        var name;

        for ( name in obj ) {
            return false;
        }

        return true;
}
```

### window

```js
function isWindow( obj ) {
    return obj != null && obj === obj.window;
}
```

### isArrayLike

```js
function isArrayLike(obj) {

    // obj 必须有 length属性
    var length = !!obj && "length" in obj && obj.length;
    var typeRes = type(obj);

    // 排除掉函数和 Window 对象
    if (typeRes === "function" || isWindow(obj)) {
        return false;
    }

    return typeRes === "array" || length === 0 ||
        typeof length === "number" && length > 0 && (length - 1) in obj;
}
```

#### 思考题

```
var a = {n: 1};
var b = a;
a.x = a = {n: 2};

a.x 	// --> undefined
b.x 	// --> {n: 2}
```

答案已经写上面了，这道题的关键在于

- 1、优先级。`.`的优先级高于`=`，所以先执行`a.x`，堆内存中的`{n: 1}`就会变成`{n: 1, x: undefined}`，改变之后相应的`b.x`也变化了，因为指向的是同一个对象。
- 2、赋值操作是`从右到左`，所以先执行`a = {n: 2}`，`a`的引用就被改变了，然后这个返回值又赋值给了`a.x`，**需要注意**的是这时候`a.x`是第一步中的`{n: 1, x: undefined}`那个对象，其实就是`b.x`，相当于`b.x = {n: 2}`